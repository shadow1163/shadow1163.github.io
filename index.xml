<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shadow1163&#39;s Blog</title>
    <link>https://shadow1163.github.io/</link>
    <description>Recent content on Shadow1163&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 Apr 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://shadow1163.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>access libvirt vms via telnet</title>
        <link>https://shadow1163.github.io/post/2020-04-30-access-libvirt-vms-via-telnet/</link>
        <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
        
        <guid>https://shadow1163.github.io/post/2020-04-30-access-libvirt-vms-via-telnet/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2020-04-30-access-libvirt-vms-via-telnet/ -&lt;p&gt;2020年4月23日，ubuntu 20.04 LTS正式发布，我的桌面机也是第一时间做了升级，升级过程中一切正常，日常使用也没有什么变化。但是另外一台ubuntu server 18.04升级之后就没那么好运了，升级之后由于无法找到LVM卷不能启动，只得用ubuntu server 20.04重装了，带来的问题是部署在这台server的KVM虚拟机没了。在配置重装的KVM主机时，遇到了一个问题是virt-manager最新版2.2.1配置serial串口时，没有了network选项。查询了virt-manager的升级日志，也没有发现这个功能被取消了。但是这个选项在ubuntu 18.04上的virt-manager 1.5.1上的确是可以正常配置的。在网络上搜索发现了可以通过XML来设置。代码片段如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;devices&amp;gt;
  &amp;lt;serial type=&amp;quot;tcp&amp;quot;&amp;gt;
    &amp;lt;source mode=&amp;quot;connect&amp;quot; host=&amp;quot;0.0.0.0&amp;quot; service=&amp;quot;4555&amp;quot;/&amp;gt;
    &amp;lt;protocol type=&amp;quot;telnet&amp;quot;/&amp;gt;
    &amp;lt;target port=&amp;quot;0&amp;quot;/&amp;gt;
  &amp;lt;/serial&amp;gt;
&amp;lt;/devices&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在virt-manager界面，进入&amp;quot;edit&amp;rdquo;-&amp;gt;&amp;quot;Prefenences&amp;rdquo;， 在general选项卡上点击&amp;quot;Enable XML editing&amp;rdquo;。然后在新创建的serial端口上进入XML配置，复制粘贴上面的配置片段，修改相应的端口号，重启KVM虚拟机后应该可以用telnet访问KVM的串口了。&lt;/p&gt;
&lt;p&gt;Link: &lt;a href=&#34;https://lukas.zapletalovi.com/2018/02/accessing-libvirt-vms-via-telnet.html&#34;&gt;https://lukas.zapletalovi.com/2018/02/accessing-libvirt-vms-via-telnet.html&lt;/a&gt;&lt;/p&gt;
- https://shadow1163.github.io/post/2020-04-30-access-libvirt-vms-via-telnet/ - </description>
        </item>
    
    
    
        <item>
        <title>MacOS Mojave install on KVM</title>
        <link>https://shadow1163.github.io/post/2018-07-25-macos-mojave-install-on-kvm/</link>
        <pubDate>Wed, 25 Jul 2018 16:10:35 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-07-25-macos-mojave-install-on-kvm/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-07-25-macos-mojave-install-on-kvm/ -&lt;p&gt;最近项目上需要在最新的MacOS 10.14上测试, 以前也在VMware ESXi上部署过MacOS 10.12，由于vmware unlocker宣布不在支持ESXi，找到另外一个KVM项目支持MacOS 10.14，那么就在KVM上部署试试吧。&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;Clone source&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/kholia/OSX-KVM
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Install QEMU&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install qemu uml-utilities libguestfs-tools
# First edit /etc/apt/sources.list to add/uncomment deb-src lines
sudo apt-get update
sudo apt-get build-dep qemu
git clone https://github.com/kholia/qemu.git
cd qemu
git checkout macOS
git submodule init
git submodule update --recursive
./configure --prefix=/home/$(whoami)/QEMU --target-list=x86_64-softmmu --audio-drv-list=pa
$ make clean; make -j8; make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在编译的时候有可能报错，&amp;ldquo;error: static declaration of memfd_create follows non-static declaration&amp;rdquo;, 可参考这个补丁。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://git.qemu.org/?p=qemu.git;a=commitdiff;h=75e5b70e6b5dcc4f2219992
--- a/configure
+++ b/configure
@@ -3923,7 +3923,7 @@ fi
 # check if memfd is supported
 memfd=no
 cat &amp;gt; $TMPC &amp;lt;&amp;lt; EOF
-#include &amp;lt;sys/memfd.h&amp;gt;
+#include &amp;lt;sys/mman.h&amp;gt;

 int main(void)
 --- a/util/memfd.c
 +++ b/util/memfd.c
 @@ -31,9 +31,7 @@

  #include &amp;quot;qemu/memfd.h&amp;quot;

 -#ifdef CONFIG_MEMFD
 -#include &amp;lt;sys/memfd.h&amp;gt;
 -#elif defined CONFIG_LINUX
 +#if defined CONFIG_LINUX &amp;amp;&amp;amp; !defined CONFIG_MEMFD
  #include &amp;lt;sys/syscall.h&amp;gt;
  #include &amp;lt;asm/unistd.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Create HD disk file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;qemu-img create -f qcow2 mac_hdd.img 128G
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;boot--install-macos&#34;&gt;Boot &amp;amp; Install macOS&lt;/h2&gt;
&lt;p&gt;在项目根目录下有一个启动脚本文件，&amp;ldquo;boot-macOS-Mojave.sh&amp;rdquo;，其中有几个参数可能需要修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mac_hdd.img文件需要填写正确的目录&lt;/li&gt;
&lt;li&gt;ISO文件需要修改位对应的目录&lt;/li&gt;
&lt;li&gt;qemu-system-x86_64替换为安装到Home下的目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改完成之后支持&amp;quot;boot-macOS-Mojave.sh&amp;quot;即可安装.&lt;/p&gt;
- https://shadow1163.github.io/post/2018-07-25-macos-mojave-install-on-kvm/ - </description>
        </item>
    
    
    
        <item>
        <title>ngrok intro</title>
        <link>https://shadow1163.github.io/post/2018-07-20-ngrok-intro/</link>
        <pubDate>Fri, 20 Jul 2018 16:07:16 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-07-20-ngrok-intro/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-07-20-ngrok-intro/ -&lt;p&gt;最近做Jenkins和Github的集成，计划是收到一个代码的Push就执行一次测试。但是同时遇到一个问题，由于Jenkins没有设置公有IP，导致了Github上设置的webhook无法跟Jenkins通信。在无法设置公有IP的情况下，通过一个小工具来解决这个问题。这个工具叫ngrok。官网：https://ngrok.com/ 。&lt;/p&gt;
&lt;h2 id=&#34;下载登录&#34;&gt;下载登录&lt;/h2&gt;
&lt;p&gt;进入官网后，注册或者通过社交账号登录都可以，下载ngrok，解压后执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./ngrok authtoken &amp;lt;your Auth code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;开启&#34;&gt;开启&lt;/h2&gt;
&lt;p&gt;在连接之后，就可以开始使用了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./ngrok help
./ngrok http 80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行第二条命令会看到如下格式的记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Forwarding                    http://xxxxxxxx.ngrok.io -&amp;gt; 127.0.0.1:80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个网址就可以放在github的webhook中，通过这个网址就可以和本地80端口通信了。&lt;/p&gt;
&lt;h2 id=&#34;automation&#34;&gt;Automation&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ngrok -log=stdout 80 &amp;gt; /dev/null &amp;amp;
curl localhost:4040/api/tunnels
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两条命令是后台启动ngrok, 使用API获取转换域名。&lt;/p&gt;
- https://shadow1163.github.io/post/2018-07-20-ngrok-intro/ - </description>
        </item>
    
    
    
        <item>
        <title>jmeter 4.0 distributed testing with docker</title>
        <link>https://shadow1163.github.io/post/2018-07-20-jmeter-4-0-distributed-testing-with-docker/</link>
        <pubDate>Fri, 20 Jul 2018 15:13:04 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-07-20-jmeter-4-0-distributed-testing-with-docker/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-07-20-jmeter-4-0-distributed-testing-with-docker/ -&lt;p&gt;Jmeter支持分布式测试，所以打算用docker来部署Master和Slave测试一下。在Master/Client下映射一个控制端口，在Slave/Server下映射两个端口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;client.rmi.localport=60000&lt;/li&gt;
&lt;li&gt;Server_port=1099&lt;/li&gt;
&lt;li&gt;server.rmi.localport=50000&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jmeter-base-dockerfile&#34;&gt;Jmeter base dockerfile&lt;/h2&gt;
&lt;p&gt;首先构建一个Jmeter的基础镜像。Master和Slave基于基础镜像再构建。基础镜像的Dockerfile如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu:18.04

MAINTAINER shadow1163 (674602286@qq.com)

RUN apt-get update &amp;amp;&amp;amp; apt-get install -y curl openjdk-8-jdk openjfx

ARG JMETER_VERSION=4.0

RUN curl http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-$JMETER_VERSION.tgz -o /opt/jmeter.tgz &amp;amp;&amp;amp; cd /opt &amp;amp;&amp;amp; tar zxf jmeter.tgz &amp;amp;&amp;amp; rm -f /opt/jmeter.tgz

ENV JMETER_HOME /opt/apache-jmeter-$JMETER_VERSION/

ENV PATH $JMETER_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jmeter-master-dockerfile&#34;&gt;Jmeter Master dockerfile&lt;/h2&gt;
&lt;p&gt;基于基础镜像构造Master&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM jmeter-wgbase
MAINTAINER shadow1163 (674602286@qq.com)
# Ports to be exposed from the container for JMeter Master
EXPOSE 60000
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jmeter-slave-dockerfile&#34;&gt;Jmeter Slave dockerfile&lt;/h2&gt;
&lt;p&gt;基于基础镜像构造Slave&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM jmeter-wgbase
MAINTAINER shadow1163 (674602286@qq.com)
# Ports to be exposed from the container for JMeter Master
EXPOSE 1099 50000
ENTRYPOINT $JMETER_HOME/bin/jmeter-server -Dserver.rmi.localport=50000 -Dserver_port=1099 -Jserver.rmi.ssl.disable=true
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;
&lt;p&gt;在Jmeter 4.0里，client和server的连接默认开启了RMI keystore. 有两个解决办法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭RMI keystore&lt;/li&gt;
&lt;li&gt;生成一个RMI keystore 文件，并应用于Jmeter&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;disable-rmi-keystore&#34;&gt;Disable RMI Keystore&lt;/h3&gt;
&lt;p&gt;在启动的命令行加上&amp;rdquo;-Jserver.rmi.ssl.disable=true&amp;quot;即可。可以看到Slave的dockerfile里，就是采用的这种方式, Master上也需要加上同样的参数。&lt;/p&gt;
&lt;h3 id=&#34;secure-our-channel&#34;&gt;Secure our channel&lt;/h3&gt;
&lt;p&gt;到Jmeter的执行目录下，执行create-rmi-keystore命令，生成rmi_keystore.jks文件。在启动Container时，把这个文件添加进去。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slave/server端添加参数-Jserver.rmi.ssl.keystore.file=${jmeter_path}/rmi_keystore.jks&lt;/li&gt;
&lt;li&gt;Master/client端添加参数-Jserver.rmi.ssl.keystore.file=${jmeter_path}/rmi_keystore.jks&lt;/li&gt;
&lt;/ul&gt;
- https://shadow1163.github.io/post/2018-07-20-jmeter-4-0-distributed-testing-with-docker/ - </description>
        </item>
    
    
    
        <item>
        <title>openwrt on vmware workstation &amp; ESXi</title>
        <link>https://shadow1163.github.io/post/2018-07-12-openwrt-on-vmware-workstation-esxi/</link>
        <pubDate>Thu, 12 Jul 2018 15:22:40 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-07-12-openwrt-on-vmware-workstation-esxi/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-07-12-openwrt-on-vmware-workstation-esxi/ -&lt;p&gt;最近需要一个搭一个DHCP server，所有的主机都放在了一台很老的DELL服务器上搭建的ESXi主机上，资源相对很少，想到之前用过的openwrt比较适合这种场景。我的ESXi的版本是6.5，应该是向前兼容的。&lt;/p&gt;
&lt;p&gt;首先在官网上下载img文件，然后解压缩，转换为VMDK格式的文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gunzip openwrt-x86-generic-combined-ext4.img.gz
qemu-img convert -f raw -O vmdk openwrt-x86-generic-combined-ext4.img openwrt-x86-generic-combined-ext4.vmdk
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有qemu-img，记得先安装。&lt;/p&gt;
&lt;p&gt;接下来就是把vmdk文件上传到ESXi服务器的磁盘里，最好是创建一个单独的文件夹来存放。
然后创建一个32bit的主机，设置好处理器个数和内存，然后删除自动创建的磁盘，添加一个已存在的磁盘，文件设置为你上传的文件。磁盘的类型最好设置为IDE，网卡的类型为E1000。设置好之后，启动主机就可以看到openwrt可以正常运行了。&lt;/p&gt;
&lt;p&gt;Refer to: &lt;a href=&#34;https://wiki.openwrt.org/doc/howto/vmware&#34;&gt;https://wiki.openwrt.org/doc/howto/vmware&lt;/a&gt;&lt;/p&gt;
- https://shadow1163.github.io/post/2018-07-12-openwrt-on-vmware-workstation-esxi/ - </description>
        </item>
    
    
    
        <item>
        <title>httpstat – A Curl Statistics Tool to Check Website Performance</title>
        <link>https://shadow1163.github.io/post/2018-05-04-intro-httpstat/</link>
        <pubDate>Fri, 04 May 2018 14:48:53 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-05-04-intro-httpstat/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-05-04-intro-httpstat/ -&lt;p&gt;The httpstat is a tool that reflects curl statistics in a fascinating and well-defined way.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shadow1163.github.io/images/example.png&#34; alt=&#34;example&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;The httpstat has been implemented by golang or python.&lt;/p&gt;
&lt;h3 id=&#34;install-by-python&#34;&gt;Install by python&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Get it directly from its github repo using the wget commands as follows:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;wget -c https://raw.githubusercontent.com/reorx/httpstat/master/httpstat.py
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Using pip like this&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo -H pip install httpstat
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;install-by-golang&#34;&gt;Install by golang&lt;/h3&gt;
&lt;h4 id=&#34;notice&#34;&gt;Notice&lt;/h4&gt;
&lt;p&gt;httpstat requires Go 1.7.1 or later&lt;/p&gt;
&lt;p&gt;Install it like this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go get -u github.com/davecheney/httpstat
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;how-to-use&#34;&gt;How to use&lt;/h2&gt;
&lt;p&gt;List help info&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;httpstat --help
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Access watchguard website&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;httpstat www.watchguard.com

Connected to 104.17.60.6:443

HTTP/2.0 200 OK
Server: cloudflare
Cache-Control: public, max-age=1800
Cf-Cache-Status: MISS
Cf-Ray: 415919205adc930c-SJC
Content-Language: en
Content-Type: text/html; charset=utf-8
Date: Fri, 04 May 2018 07:01:48 GMT
Expect-Ct: max-age=604800, report-uri=&amp;quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&amp;quot;
Expires: Sun, 19 Nov 1978 05:00:00 GMT
Last-Modified: Fri, 04 May 2018 06:56:19 GMT
Link: &amp;lt;https://www.watchguard.com&amp;gt;; rel=&amp;quot;canonical&amp;quot;,&amp;lt;https://www.watchguard.com/&amp;gt;; rel=&amp;quot;shortlink&amp;quot;
Set-Cookie: __cfduid=dd1ef17a31a0b0aacf4df8cdbfe1d38ec1525417308; expires=Sat, 04-May-19 07:01:48 GMT; path=/; domain=.watchguard.com; HttpOnly,BIGipServerwatchguard.com-p443=2348340278.47873.0000; expires=Fri, 04-May-2018 19:00:56 GMT; path=/; Httponly; Secure
Vary: Cookie,Accept-Encoding
Via: 1.1 varnish-v4
X-Ah-Environment: prod
X-Cache: HIT
X-Cache-Hits: 105
X-Drupal-Cache: HIT
X-Frame-Options: SAMEORIGIN
X-Request-Id: v-5a0ca084-4f68-11e8-8ffd-22000a6746ba
X-Varnish: 16916405 16916090

Body discarded

  DNS Lookup   TCP Connection   TLS Handshake   Server Processing   Content Transfer
[      9ms  |         183ms  |        438ms  |            324ms  |           189ms  ]
            |                |               |                   |                  |
   namelookup:9ms            |               |                   |                  |
                       connect:192ms         |                   |                  |
                                   pretransfer:630ms             |                  |
                                                     starttransfer:955ms            |
                                                                                total:1144ms
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;p&gt;Now, we would create a demo to verify the Server Processing time is accurately or not. We would create a http server, listened to a port, sleep some time. In the end, verify the time what show by httpstat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;net/http&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;
)

func sayHello(w http.ResponseWriter, r *http.Request) {
	message := r.URL.Path
	message = strings.TrimPrefix(message, &amp;quot;/&amp;quot;)
	message = &amp;quot;Hello &amp;quot; + message
	time.Sleep(2 * time.Second)
	w.Write([]byte(message))
}
func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, sayHello)
	if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {
		panic(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run the code, it would listened to 8080 port, and sleep 2 seconds.&lt;/p&gt;
&lt;p&gt;Accsss the http service using httpstat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;httpstat http://127.0.0.1:8080

Connected to 127.0.0.1:8080

HTTP/1.1 200 OK
Content-Length: 6
Content-Type: text/plain; charset=utf-8
Date: Fri, 04 May 2018 07:18:42 GMT

Body discarded

   DNS Lookup   TCP Connection   Server Processing   Content Transfer
[       0ms  |           4ms  |           2002ms  |             0ms  ]
             |                |                   |                  |
    namelookup:0ms            |                   |                  |
                        connect:4ms               |                  |
                                      starttransfer:2006ms           |
                                                                 total:2007ms
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see the Server Processing time is 2002ms.&lt;/p&gt;
&lt;h2 id=&#34;use-it-in-golang-source-code&#34;&gt;Use it in golang source code&lt;/h2&gt;
&lt;p&gt;We can use other golang package &amp;ldquo;github.com/tcnksm/go-httpstat&amp;rdquo;, it can show the Server Processing in golang code.&lt;/p&gt;
&lt;p&gt;Example is here&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;time&amp;quot;

	httpstat &amp;quot;github.com/tcnksm/go-httpstat&amp;quot;
)

func main() {
	req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://127.0.0.1:8080&amp;quot;, nil)
	if err != nil {
		log.Fatal(err)
	}
	// Create a httpstat powered context
	var result httpstat.Result
	ctx := httpstat.WithHTTPStat(req.Context(), &amp;amp;result)
	req = req.WithContext(ctx)
	// Send request by default HTTP client
	client := http.DefaultClient
	res, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := io.Copy(ioutil.Discard, res.Body); err != nil {
		log.Fatal(err)
	}
	res.Body.Close()
	// end := time.Now()
	// Show the results
	log.Printf(&amp;quot;DNS lookup: %d ms&amp;quot;, int(result.DNSLookup/time.Millisecond))
	log.Printf(&amp;quot;TCP connection: %d ms&amp;quot;, int(result.TCPConnection/time.Millisecond))
	log.Printf(&amp;quot;TLS handshake: %d ms&amp;quot;, int(result.TLSHandshake/time.Millisecond))
	log.Printf(&amp;quot;Server processing: %d ms&amp;quot;, int(result.ServerProcessing/time.Millisecond))
	log.Printf(&amp;quot;Content transfer: %d ms&amp;quot;, int(result.ContentTransfer(time.Now())/time.Millisecond))
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run it, you can see this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go run httpstatExample.go
2018/05/04 15:27:58 DNS lookup: 0 ms
2018/05/04 15:27:58 TCP connection: 1 ms
2018/05/04 15:27:58 TLS handshake: 0 ms
2018/05/04 15:27:58 Server processing: 2001 ms
2018/05/04 15:27:58 Content transfer: 8 ms
&lt;/code&gt;&lt;/pre&gt;- https://shadow1163.github.io/post/2018-05-04-intro-httpstat/ - </description>
        </item>
    
    
    
        <item>
        <title>Golang 并发定量协程数量</title>
        <link>https://shadow1163.github.io/post/2018-03-23-gorouting-with-buffered-channel/</link>
        <pubDate>Fri, 23 Mar 2018 10:15:12 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-03-23-gorouting-with-buffered-channel/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-03-23-gorouting-with-buffered-channel/ -&lt;p&gt;最近需要用到golang做一个并发测试，之前大概看了一遍并发，对基本的流程有了一个了解了。我的需求是启动固定数量的客户端程序，然后等待程序运行完成后收集分析一下结果即可。参照网上的代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func Afunction(ch chan int) {
	fmt.Println(&amp;quot;finish&amp;quot;)
	&amp;lt;-ch
}

func main() {
	ch := make(chan int, 10)
	for i := 0; i &amp;lt; 1000; i++ {
		ch &amp;lt;- 1
		go Afunction(ch)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行了一下感觉没问题就没仔细检查了。结果领导发现运行结果差10个，然后才来仔细看程序，在main函数中的for循环调用完函数后并不会阻塞等待被调用的函数执行完成。main函数退出后，并发的协程也会被自动回收，就导致了结果差10个。
解决的办法是在for循环后添加代码等待协程执行完成，然后退出。有两种方法。&lt;/p&gt;
&lt;h3 id=&#34;syncwaitgroup&#34;&gt;sync.WaitGroup&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;sync&amp;quot;
)

var waitgroup sync.WaitGroup

func Afunction(ch chan int) {
	fmt.Println(&amp;quot;finish&amp;quot;)
	&amp;lt;-ch
  waitgroup.Done()
}

func main() {
	ch := make(chan int, 10)
	for i := 0; i &amp;lt; 1000; i++ {
		ch &amp;lt;- 1
    waitgroup.Add(1)
		go Afunction(ch)
	}
  waitgroup.Wait()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于要限制协程的数量，所以不能不用channel。虽然程序有些臃肿，但还是工作的。&lt;/p&gt;
&lt;h3 id=&#34;channel&#34;&gt;channel&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func Afunction(ch chan int) {
	fmt.Println(&amp;quot;finish&amp;quot;)
	&amp;lt;-ch
}

func main() {
	ch := make(chan int, 10)
	for i := 0; i &amp;lt; 1000; i++ {
		ch &amp;lt;- 1
		go Afunction(ch)
	}
  for {
    if len(ch) {
      break
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外可以通过判断channel的缓存数量来等待协程的运行完成。总之使用并发要非常小心。&lt;/p&gt;
- https://shadow1163.github.io/post/2018-03-23-gorouting-with-buffered-channel/ - </description>
        </item>
    
    
    
        <item>
        <title>Apache Jmeter 入门</title>
        <link>https://shadow1163.github.io/post/2018-02-24-jmeter-intro/</link>
        <pubDate>Sat, 24 Feb 2018 16:26:21 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-02-24-jmeter-intro/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-02-24-jmeter-intro/ -&lt;p&gt;很早之前就听到过Jmeter，最近项目上需要用到Jmeter，就看了看相关的资料。&lt;/p&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;Apache JMeter 是100%纯JAVA桌面应用程序，被设计为用于测试CS结构的软件。 同时也可以用来测试静态和动态资源的性能，例如：静态文件，Java Servlets，CGI Scripts，Java Object，数据库和FTP服务器等等。JMeter可用于模拟大量负载来测试一台服务器，网络或者对象的健壮性或者分析不同负载下的整体性能.&lt;/p&gt;
&lt;p&gt;同时，JMeter可以帮助你对你的应用程序进行回归测试。通过你创建的测试脚本和assertions来验证你的程序返回了所期待的值。为了更高的适应性，JMeter允许你使用常规表达式来创建这些assertions.
jmeter的未来： 随着开发人员借助它的可嵌入的结构，希望看到JMeter的能力也随之快速的被扩大。更进一步的主要发展目标是把JMeter在没有减弱它的负载测试的能力的同时尽可能的做成最有效的回归测试工具.&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从 &lt;a href=&#34;http://jmeter.apache.org/&#34;&gt;http://jmeter.apache.org/&lt;/a&gt; 下载最新版本的JMeter，解压文件到你的工作目录。&lt;/li&gt;
&lt;li&gt;安装JAVA，配置好JAVA_HOME&lt;/li&gt;
&lt;li&gt;JMeter可运行在Windows系统，类Unix的系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意JMeter的目录不能空格。&lt;/p&gt;
&lt;h2 id=&#34;运行&#34;&gt;运行&lt;/h2&gt;
&lt;p&gt;进入JMeter的安装目录下的bin目录，运行jmeter.bat(windows)或jmeter.sh(类Unix)。
打开JMeter的主界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shadow1163.github.io/images/jmeter-ui.png&#34; alt=&#34;JMeter4.0主界面&#34;&gt;&lt;/p&gt;
&lt;p&gt;在JMeter4.0里取消了工作台，相关的功能合并到了测试计划里了。
右键单击&amp;quot;Test Plan&amp;quot;弹出菜单选择添加线程组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shadow1163.github.io/images/jmeter-add.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后设置线程组的相关属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shadow1163.github.io/images/jmeter-thread-group.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;右键单击线程组，添加http request&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shadow1163.github.io/images/jmeter-request.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;录制&#34;&gt;录制&lt;/h2&gt;
&lt;p&gt;除了手动添加测试组件，还可以使用脚本录制的方法生成测试脚本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加线程组&lt;/li&gt;
&lt;li&gt;添加http request defaults设置默认的URL&lt;/li&gt;
&lt;li&gt;添加录制控制器&lt;/li&gt;
&lt;li&gt;添加http代理服务器&lt;/li&gt;
&lt;li&gt;打开http代理服务器&lt;/li&gt;
&lt;li&gt;把浏览器的代理服务器设置为之前配置的代理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式&#34;&gt;分布式&lt;/h2&gt;
&lt;p&gt;在使用Jmeter进行性能测试时，如果并发数比较大(比如最近项目需要支持1000并发)，单台电脑的配置(CPU和内存)可能无法支持，这时可以使用Jmeter提供的分布式测试的功能。&lt;/p&gt;
&lt;h4 id=&#34;slave&#34;&gt;Slave&lt;/h4&gt;
&lt;p&gt;在主机上安装同版本的jmeter，然后执行jmeter-server.bat(windows)或jmeter-server.sh(类unix)。启动成功后如下：
{% asset_img slave.png %}&lt;/p&gt;
&lt;h4 id=&#34;master&#34;&gt;Master&lt;/h4&gt;
&lt;p&gt;找到Jmeter的bin目录下jmeter.properties文件，修改如下配置，IP和Port是slave机的IP以及自定义的端口&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;remote_hosts=127.0.0.1,10.2.2.3，10.1.1.4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加之后就可以选择远程执行了
{% asset_img remote-host.png %}&lt;/p&gt;
- https://shadow1163.github.io/post/2018-02-24-jmeter-intro/ - </description>
        </item>
    
    
    
        <item>
        <title>Ubuntu 16.04 Samba 使用 openldap 验证</title>
        <link>https://shadow1163.github.io/post/2018-01-31-ldap-samba-configuration/</link>
        <pubDate>Wed, 31 Jan 2018 10:53:41 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-01-31-ldap-samba-configuration/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-01-31-ldap-samba-configuration/ -&lt;h2 id=&#34;directory-services目录服务&#34;&gt;Directory Services(目录服务)&lt;/h2&gt;
&lt;p&gt;我们知道，当局域网的规模变的越来越大时，为了方便主机管理，我们使用DHCP来实现IP地址、以太网地址、主机名和拓扑结构等的集中管理和统一分配。同样，如果一个局域网内有许多的其它资源时，如打印机、共享文件夹等等，为了方便的定位及查找它们，一种集中定位管理的方式或许是较好的选择，DNS和NIS都是用来实现类似管理的方法。&lt;/p&gt;
&lt;p&gt;对于局域网内的一个用户来讲，工作等其它应用需要，我们必须凭帐号登录主机、用帐号收发E-mail，甚至为了管理需要公司还需要维护一个电子号码簿来存储员工的姓名、地址、电话号码等信息。随着时间的增长，我们会为这些越来越多的帐号和密码弄的头晕脑胀。同时，如果一个员工离开，管理员就不得不翻遍所有的记录帐号信息的文件把离职员工的信息删除。这些将是一个繁琐而效率低下的工作。那么，如果能将此些帐号信息等统一到一个文件中进行管理，无疑会大大提高员工及管理员的工作效率。目录服务（LDAP是其实现的一种）正是基于这些应用实现的。&lt;/p&gt;
&lt;h2 id=&#34;ldap&#34;&gt;LDAP&lt;/h2&gt;
&lt;p&gt;LDAP是Lightweight Directory Access Protocol的缩写，顾名思义，它是指轻量级目录访问协议（这个主要是相对另一目录访问协议X.500而言的；LDAP略去了x.500中许多不太常用的功能，且以TCP/IP协议为基础）。目录服务和数据库很类似，但又有着很大的不同之处。数据库设计为方便读写，但目录服务专门进行了读优化的设计，因此不太适合于经常有写操作的数据存储。同时，LDAP只是一个协议，它没有涉及到如何存储这些信息，因此还需要一个后端数据库组件来实现。这些后端可以 是bdb(BerkeleyDB)、ldbm、shell和passwd等。&lt;/p&gt;
&lt;p&gt;LDAP目录以树状的层次结构来存储数据（这很类同于DNS），最顶层即根部称作“基准DN”，形如&amp;quot;dc=mydomain,dc=org&amp;quot;或者&amp;quot;o= mydomain.org&amp;rdquo;，前一种方式更为灵活也是Windows AD中使用的方式。在根目录的下面有很多的文件和目录，为了把这些大量的数据从逻辑上分开，LDAP像其它的目录服务协议一样使用OU （Organization Unit），可以用来表示公司内部机构，如部门等，也可以用来表示设备、人员等。同时OU还可以有子OU，用来表示更为细致的分类。&lt;/p&gt;
&lt;p&gt;LDAP中每一条记录都有一个唯一的区别于其它记录的名字DN（Distinguished Name）,其处在“叶子”位置的部分称作RDN；如dn:cn=tom,ou=animals,dc=mydomain,dc=org中tom即为 RDN；RDN在一个OU中必须是唯一的。&lt;/p&gt;
&lt;p&gt;因为LDAP数据是“树”状的，而且这棵树是可以无限延伸的，假设你要树上的一个苹果（一条记录），你怎么告诉园丁它的位置呢？当然首先要说明是哪一棵树（dc，相当于MYSQL的DB），然后是从树根到那个苹果所经过的所有“分叉”（ou，呵呵MYSQL里面好象没有这 DD），最后就是这个苹果的名字（uid，记得我们设计MYSQL或其它数据库表时，通常为了方便管理而加上一个‘id’字段吗？）。好了！这时我们可以清晰的指明这个苹果的位置了，就是那棵“歪脖树”的东边那个分叉上的靠西边那个分叉的再靠北边的分叉上的半红半绿的……，晕了！你直接爬上去吧！我还是说说LDAP里要怎么定义一个字段的位置吧，树（dc=waibo,dc=com)，分叉（ou=bei,ou=xi,ou= dong），苹果（cn=honglv），好了！位置出来了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dn:cn=honglv,ou=bei,ou=xi,ou=dong,dc=waibo,dc=com
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;samba&#34;&gt;Samba&lt;/h2&gt;
&lt;p&gt;Samba是由Andrew Tridgell在1991年（和Linux诞生的时间接近）制作的，当时他使用的是DEC的Pathworks网络，但是他发现无法同时使用Sun的NFS协议（正如我们前面介绍的，NFS是一个非常有用的网络协议），于是，连Socket（套接字）都不熟悉的他开始尝试自己在PC机上实现NFS，经过不断的摸索，他终于在自己的计算机上实现了NFS，采用的网络协议是NetBIOS（因为NetBIOS是公开的，可以合法地得到）。到了1992年1月，他开发出了0.1版，称为Server 0.1，随后又开发了一段时间，由于得到了X终端，他放弃了进一步的开发。直到1992年底，从一封电子邮件中，Andrew Tridgell获知了Linux，一个爱好者将Server 1.0转换到了Linux上，很快，人们发现这个程序可以直接使用，应用户的要求，Adrew Tridgell开始在Linux上开发，同时他发现smb-server已经被别人注册了，所以就只好起名为Samba，这就是Samba这个名称的由来。&lt;/p&gt;
&lt;p&gt;Samba是种自由软件，用来让UNIX系列的操作系统与微软Windows操作系统的SMB/CIFS(Server Message Block/Common Internet File System)网络协定做连结。不仅可存取及分享SMB的资料夹及打印机，本身还可以整合入Windows Server的网域、扮演为网域控制站(Domain Controller)以及加入Active Directory成员。简而言之，此软件在Windows与UNIX系列OS之间搭起一座桥梁，让两者的资源可互通有无。&lt;/p&gt;
&lt;h2 id=&#34;集成安装&#34;&gt;集成安装&lt;/h2&gt;
&lt;p&gt;以下安装基于Ubuntu 16.04 docker&lt;/p&gt;
&lt;h3 id=&#34;samba-1&#34;&gt;Samba&lt;/h3&gt;
&lt;p&gt;首先安装和配置Samba，可以通过apt来安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install -y samba samba-common python-glade2 system-config-samba
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;备份配置文件，生成一个新的空的配置文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp -pf /etc/samba/smb.conf /etc/samba/smb.conf.bak
cat /dev/null  &amp;gt; /etc/samba/smb.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加以下内容到配置文件，生成一个匿名共享目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[global]
workgroup = WORKGROUP
server string = Samba Server %v
netbios name = ubuntu
security = user
map to guest = bad user
dns proxy = no

#============================ Share Definitions ==============================

[Anonymous]
path = /samba/anonymous
browsable =yes
writable = yes
guest ok = yes
read only = no
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成共享目录,修改权限。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /samba/anonymous
chmod -R 0775 /samba/anonymous
chown -R nobody:nogroup /samba/anonymous
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service smbd restart
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以测试一下匿名共享目录是否可以访问，windows(&amp;quot;\ubuntu\Anonymous&amp;rdquo;)或者Linux(smbclient //ubuntu/Anonymous)。如果有问题就需要查看log检查问题。&lt;/p&gt;
&lt;h3 id=&#34;openldap&#34;&gt;Openldap&lt;/h3&gt;
&lt;p&gt;用apt安装openldap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install slapd ldap-utils
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要修改配置可以用以下命令重新配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo dpkg-reconfigure slapd
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Omit OpenLDAP server configuration—answer No&lt;/li&gt;
&lt;li&gt;DNS domain name—enter your correct A record for your domain name (or a subdomain)&lt;/li&gt;
&lt;li&gt;Organization Name—enter the name of your organization (such as company or division)&lt;/li&gt;
&lt;li&gt;Administrator password—enter the same password you used during the installation&lt;/li&gt;
&lt;li&gt;Database backend—select MDB&lt;/li&gt;
&lt;li&gt;Remove database—select No&lt;/li&gt;
&lt;li&gt;Move old database—select Yes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不太习惯命令行可以使用Web界面，安装phpldapadmin。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install phpldapadmin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装完成之后编辑/etc/phpldapadmin/config.php修改配置。如果没有修改base DN是可以直接使用的，修改了就做对应的修改就好了。可以打开浏览器访问 http://ubuntu/phpldapadmin 测试一下。&lt;/p&gt;
&lt;p&gt;关于openldap和samba的更多配置可以查看参考连接。&lt;/p&gt;
&lt;h3 id=&#34;samba-and-ldap&#34;&gt;Samba and LDAP&lt;/h3&gt;
&lt;p&gt;首先安装两个软件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt install samba smbldap-tools
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;ldap-配置&#34;&gt;LDAP 配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Import a schema&lt;/li&gt;
&lt;li&gt;Index some entries&lt;/li&gt;
&lt;li&gt;Add objects&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用以下命令导入samba的schema&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zcat /usr/share/doc/samba/examples/LDAP/samba.ldif.gz | sudo ldapadd -Q -Y EXTERNAL -H ldapi:///
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查一下导入的schema&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=schema,cn=config &#39;cn=*samba*&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个samba_indices.ldif文件，导入一下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dn: olcDatabase={1}mdb,cn=config
changetype: modify
replace: olcDbIndex
olcDbIndex: objectClass eq
olcDbIndex: uidNumber,gidNumber eq
olcDbIndex: loginShell eq
olcDbIndex: uid,cn eq,sub
olcDbIndex: memberUid eq,sub
olcDbIndex: member,uniqueMember eq
olcDbIndex: sambaSID eq
olcDbIndex: sambaPrimaryGroupSID eq
olcDbIndex: sambaGroupType eq
olcDbIndex: sambaSIDList eq
olcDbIndex: sambaDomainName eq
olcDbIndex: default sub,eq
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加载新的文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f samba_indices.ldif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=config olcDatabase={1}mdb olcDbIndex
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加samba ldap objects&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo smbldap-config
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要特别注意，我在这里配置了很多次才成功，需要特别设置的值，workgroup name, ldap suffix, ldap master bind dn。注意，如果没有slave的话，需要在配置文件中注释掉，否则服务会起不来的。具体的配置可以参考 &lt;a href=&#34;https://www.unixmen.com/setup-samba-domain-controller-with-openldap-backend-in-ubuntu-13-04/&#34;&gt;https://www.unixmen.com/setup-samba-domain-controller-with-openldap-backend-in-ubuntu-13-04/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;备份一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo slapcat -l backup.ldif
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导入本地用户&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo smbldap-populate -g 10000 -u 10000 -r 10000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有使用本地数据库的话，这一步会失败，可以重配来解决这个问题。&lt;/p&gt;
&lt;h3 id=&#34;samba-配置&#34;&gt;Samba 配置&lt;/h3&gt;
&lt;p&gt;修改配置文件，把一下内容添加到配置文件, 如果没有使用ssl，设置ldap ssl = off。相关的值替换为你自己的值。像user，group在smbldap-populate执行后会生成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#  passdb backend = tdbsam
   workgroup = EXAMPLE

# LDAP Settings
   passdb backend = ldapsam:ldap://hostname
   ldap suffix = dc=example,dc=com
   ldap user suffix = ou=People
   ldap group suffix = ou=Groups
   ldap machine suffix = ou=Computers
   ldap idmap suffix = ou=Idmap
   ldap admin dn = cn=admin,dc=example,dc=com
   # or off if TLS/SSL is not configured
   ldap ssl = start tls
   ldap passwd sync = yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改完成后使用testparm -s测试一下配置文件是否存在错误。
配置完成后添加一个用户就可以测试环境是否存在问题。&lt;/p&gt;
&lt;p&gt;link:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://czmmiao.iteye.com/blog/1561597&#34;&gt;http://czmmiao.iteye.com/blog/1561597&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.unixmen.com/setup-samba-domain-controller-with-openldap-backend-in-ubuntu-13-04/&#34;&gt;https://www.unixmen.com/setup-samba-domain-controller-with-openldap-backend-in-ubuntu-13-04/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.howtoforge.com/tutorial/samba-server-ubuntu-16-04/&#34;&gt;https://www.howtoforge.com/tutorial/samba-server-ubuntu-16-04/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.ubuntu.com/lts/serverguide/openldap-server.html&#34;&gt;https://help.ubuntu.com/lts/serverguide/openldap-server.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
- https://shadow1163.github.io/post/2018-01-31-ldap-samba-configuration/ - </description>
        </item>
    
    
    
        <item>
        <title>ubuntu编译dockerfile如何输入密码</title>
        <link>https://shadow1163.github.io/post/2018-01-26-dockerfile-password/</link>
        <pubDate>Fri, 26 Jan 2018 15:57:16 +0800</pubDate>
        
        <guid>https://shadow1163.github.io/post/2018-01-26-dockerfile-password/</guid>
        <description>Shadow1163&#39;s Blog https://shadow1163.github.io/post/2018-01-26-dockerfile-password/ -&lt;p&gt;在Docker上使用Dockerfile构建docker image时，有的安装程序会要求输入密码，这个时候又不能交互输入。在类debian的系统中，最常见的安装软件的方式是使用apt-get，在这种方式下可以尝试使用debconf-set-selections来设置你的密码。以最常见的Mysql举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export DEBIAN_FRONTEND=&amp;quot;noninteractive&amp;quot;

sudo debconf-set-selections &amp;lt;&amp;lt;&amp;lt; &amp;quot;mysql-server mysql-server/root_password password $1&amp;quot;
sudo debconf-set-selections &amp;lt;&amp;lt;&amp;lt; &amp;quot;mysql-server mysql-server/root_password_again password $1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条命令有的版本会起作用，有的版本却无效，原因是参数可能会有变化。可以使用debconf-get-selections检查一下。如果命令找不到，就先安装一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install -y debconf-utils
&lt;/code&gt;&lt;/pre&gt;- https://shadow1163.github.io/post/2018-01-26-dockerfile-password/ - </description>
        </item>
    
    
  </channel>
</rss> 